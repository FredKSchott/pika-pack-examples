{"version":3,"sources":["src/index.ts"],"names":[],"mappings":"8MA4BE,IACA,IACA,AAAI,OAGC,AAAQ,MAAb,EAAgB,EAAI,KACb,AAAQ,MAAb,EAAgB,EAAI,KACR,EAAgB,YAAM,EAAW,OAAa,EAAY,SAnBxE,AAAW,AAAC,EAAI,AAAI,SAAU,QAkBL,WADF,iBASb,EAAI,KACJ,EAAI,OAId,EAAgB,EAAI,KACO,EAAI,UACR,EAAI,EAAI,GAAnB,QACL,AAAQ,MAAb,EAAgB,EAAI,KAMlB,AAAqB,AACnB,AANuB,EAAI,sBAMV,GAAK,cAAiB,IAAK,AALzB,EAAI,EAAI,GAAnB,oBAKqD,IAC7D,cAAiB,IAA2B,cAAiB,IAC7D,cAAiB,IAAK,cAAiB,IAAK,cAAiB,MAI/D,AAAI,AADJ,AApD6B,AAAhB,AAAC,AAAI,QAAU,QAqDjB,KAAG,AAER,EAAkB,GAAW,mEAElB,EAAW,WACrB,AAED,EAAkB,mBAAa,EAAY,UAtDrD,AAAW,AAAC,EAAI,AAAI,SAAU,GAOpB,AAAY,EAAK,MAAjB,AADF,AAAS,EAAO,GAAM,aACd,SA2BS,WAHF,kBAiCvB,EAAiB,EAAK,KACpB,AAAI,qBAA8B,EAAY,UADvB,WAGpB,AAAS,MAAd,EAAiB,EAAK,KACpB,AAAI,OApEN,AAAW,AAAC,EAAI,AAAI,SAAU,GAoEM,EAAY,UADvB","sourceRoot":"assemblyscript:///","sourceContents":["// see: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\n// Configuration imported from JS\nimport { BGR_ALIVE, BGR_DEAD, BIT_ROT } from \"./config\";\n\nvar w: i32, h: i32, s: i32;\n\n/** Gets an input pixel in the range [0, s]. */\n@inline\nfunction get(x: u32, y: u32): u32 {\n  return load<u32>((y * w + x) << 2);\n}\n\n/** Sets an output pixel in the range [s, 2*s]. */\n@inline\nfunction set(x: u32, y: u32, v: u32): void {\n  store<u32>((s + y * w + x) << 2, v);\n}\n\n/** Sets an output pixel in the range [s, 2*s] while fading it out. */\n@inline\nfunction rot(x: u32, y: u32, v: u32): void {\n  var a = max<i32>((v >>> 24) - BIT_ROT, 0);\n  set(x, y, (a << 24) | (v & 0x00ffffff));\n}\n\n/** Initializes width and height. Called once from JS. */\nexport function init(width: i32, height: i32): void {\n  w = width;\n  h = height;\n  s = width * height;\n\n  // Start by filling output with random live cells.\n  for (let y = 0; y < h; ++y) {\n    for (let x = 0; x < w; ++x) {\n      set(x, y, Math.random() > 0.1 ? BGR_DEAD & 0x00ffffff : BGR_ALIVE | 0xff000000);\n    }\n  }\n}\n\n/** Performs one step. Called about 30 times a second from JS. */\nexport function step(): void {\n  var hm1 = h - 1, // h - 1\n      wm1 = w - 1; // w - 1\n\n  // The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square\n  // \"cells\", each of which is in one of two possible states, alive or dead.\n  for (let y = 0; y < h; ++y) {\n    let ym1 = y == 0 ? hm1 : y - 1,\n        yp1 = y == hm1 ? 0 : y + 1;\n    for (let x = 0; x < w; ++x) {\n      let xm1 = x == 0 ? wm1 : x - 1,\n          xp1 = x == wm1 ? 0 : x + 1;\n\n      // Every cell interacts with its eight neighbours, which are the cells that are horizontally,\n      // vertically, or diagonally adjacent. Least significant bit indicates alive or dead.\n      let aliveNeighbors = (\n        (get(xm1, ym1) & 1) + (get(x  , ym1) & 1) + (get(xp1, ym1) & 1) +\n        (get(xm1, y  ) & 1)                       + (get(xp1, y  ) & 1) +\n        (get(xm1, yp1) & 1) + (get(x  , yp1) & 1) + (get(xp1, yp1) & 1)\n      );\n\n      let self = get(x, y);\n      if (self & 1) {\n        // A live cell with 2 or 3 live neighbors rots on to the next generation.\n        if ((aliveNeighbors & 0b1110) == 0b0010) rot(x, y, self);\n        // A live cell with fewer than 2 or more than 3 live neighbors dies.\n        else set(x, y, BGR_DEAD | 0xff000000);\n      } else {\n        // A dead cell with exactly 3 live neighbors becomes a live cell.\n        if (aliveNeighbors == 3) set(x, y, BGR_ALIVE | 0xff000000);\n        // A dead cell with fewer or more than 3 live neighbors just rots.\n        else rot(x, y, self);\n      }\n    }\n  }\n}\n\n/** Fills the row and column indicated by `x` and `y` with random live cells. */\nexport function fill(x: u32, y: u32, p: f64): void {\n  for (let ix = 0; ix < w; ++ix) {\n    if (Math.random() < p) set(ix, y, BGR_ALIVE | 0xff000000);\n  }\n  for (let iy = 0; iy < h; ++iy) {\n    if (Math.random() < p) set(x, iy, BGR_ALIVE | 0xff000000);\n  }\n}"]}